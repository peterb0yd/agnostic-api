const { isEmpty, getFutureTimestamp } = require('./general');

/**
 * saveInstance - save single instance to the database
 * @param {object} db - the database object
 * @param {object} modelName - the beginning of the key 
 * @param {object} instance - the single instance to save
 * @param {array} indexes - (optional) the indexes used to store the data - [DO NOT include 'id']
 * @param {number} expiration - (optional) the expiration time for this key (in seconds)
 * @returns {string} key - the instance database key
 */
const saveInstance = async function (db, modelName, instance, indexes = [], expiration = false) {
    try {
        if (!isEmpty(instance)) {
            const key = `${modelName}:id:${instance.id}`;
            const instanceData = JSON.stringify(instance);
            await db.set(key, instanceData);
            // Set expiration time and store key index
            if (expiration) {
                timestamp = getFutureTimestamp(expiration);
                await db.expire(key, timestamp);
                // store key in model ID set with expiration 
                orderedSetAdd(db, modelName, 'id', expiration, key);
            } 
            // Store key index
            else {
                // store key in model ID set
                listAdd(db, modelName, 'id', key);
            }
            // Store each index
            indexes.forEach(async (indexName)=> {
                if (!instance[indexName]) return; // dont index ID or any empty fields
                const indexKey = `${modelName}:${indexName}`;
                const indexData = JSON.stringify({
                    key,
                    expiration
                });
                await db.hset(indexKey, instance[indexName], indexData);
                console.log(`stored index ${indexKey}`);
            });
            return key;
        }
    }
    catch (error) {
        throw error;
    }
};
exports.saveInstance = saveInstance;

/**
 * saveInstances - save multiple instances to the database
 * * be careful! - this will overwrite the current data
 * @param {array} instances - the array of instances to save
 */
exports.saveInstances = async function (db, modelName, instances) {
    try {
        if (!isEmpty(instances)) {
            const queryArray = [];
            instances.forEach(instance => {
                const key = `${modelName}:id:${instance.id}`;
                instance = JSON.stringify(instance);
                queryArray.push(key, instance);
            });
            await db.mset(queryArray);
        }
    }
    catch (error) {
        throw error;
    }
}

/**
 * getInstance - retrieve a single instance from the DB
 * @param {object} obj.db - the database object
 * @param {string} obj.modelName - the beginning of the key
 * @param {string} obj.id - the instance id 
 * @param {string} obj.key - autoformatted key based on modelName and id
 * @returns {object} instance - in json object format
 */
const getInstance = async function ({ db, modelName, id, key = `${modelName}:id:${id}` }) {
    try {
        const instance = await db.get(key);
        return JSON.parse(instance);
    }
    catch (error) {
        throw error;
    }
};
exports.getInstance = getInstance;

/**
 * getInstanceFromIndex
 * @param {object} obj.db - the database object
 * @param {object} obj.modelName - the beginning of the key 
 * @param {string} obj.indexField - the database key for the index hash
 * @param {string} obj.indexValue - the database hash field name to pull
 * @returns {object} instance - in json object format
 */
const getInstanceFromIndex = async function ({ db, modelName, indexField, indexValue }) {
    try {
        const key = `${modelName}:${indexField}`;
        const index = await db.hget(key, indexValue);
        if (isEmpty(index)) return undefined;
        const indexObject = JSON.parse(index);
        const instanceKey = indexObject.key;
        return await getInstance({ db, key: instanceKey });
    }
    catch (error) {
        throw error;
    }
};
exports.getInstanceFromIndex = getInstanceFromIndex;

/**
 * getInstances - retrieve multiple instances from the DB
 * @param {object} obj.db - the database object
 * @param {string} obj.modelName - the beginning of the key
 * @param {array} obj.ids - the instance ids inside a string array 
 * @param {array} obj.keys - autogenerated if not passed, a string array of database id keys
 * @returns {array} instances - array of json objects
 */
const getInstances = async function ({ db, modelName, ids, keys }) {
    try {
        // set `keys` if not passed and `modelName` exists
        console.log({keys});
        if (!!modelName && isEmpty(keys)) {
            keys = ids.map(id => `${modelName}:id:${id}`);
        }
        const instances = await db.mget(keys);
        if (isEmpty(instances)) return [];
        return instances.map(instance => JSON.parse(instance));
    }
    catch (error) {
        throw error;
    }
};
exports.getInstances = getInstances;

/**
 * getInstancesFromIndex
 * @param {object} obj.db - the database object
 * @param {object} obj.modelName - the beginning of the key 
 * @param {string} obj.indexField - the database key for the index hash
 * @param {array} obj.indexValues - the database hash field names to pull inside a string array
 * @returns {array} instances - array of json objects
 */
exports.getInstancesFromIndex = async function ({ db, modelName, indexField, indexValues }) {
    try {
        const key = `${modelName}:${indexField}`;
        const indexes = await db.hmget(key, indexValues);
        if (isEmpty(indexes)) return [];
        const indexObjects = indexes.map(index => JSON.parse(index));
        const allInstanceKeys = indexObjects.filter(obj => obj).map(({key}) => key);
        return await getInstances({db, keys: allInstanceKeys});
    }
    catch (error) {
        throw error;
    }
};

/**
 * listInstances 
 * @param {object} obj.db - the database object
 * @param {object} obj.modelName - the beginning of the key 
 * @param {object} obj.expiration - the instance expiration time object 
 * @param {number} obj.offset - the offset number to look for instances
 * @param {number} obj.limit - the limit of instances
 * @returns {array} instances - array of json objects
 */
exports.listInstances = async function ({ db, modelName, expiration, offset, limit }) {
    try {
        const key = `${modelName}:id`;
        const [ start, stop ] = [ offset, offset + limit ];
        let keys;
        if (isEmpty(expiration)) {
            keys = await db.lrange(key, start, stop);
        } else {
            keys = await db.zrange(key, start, stop);
        }
        console.log({key, offset, limit});
        console.log({keys});
        if (isEmpty(keys)) return [];
        return await getInstances({ db, keys });
    }
    catch (error) {
        throw error;
    }
}

/**
 * updateInstance - update the database instance with new values
 * @param {object} obj.db - the database client
 * @param {string} obj.modelName - name of the new instance model
 * @param {object} obj.bodyInstance - the new instance data, can be a subset of full instance
 * @param {object} obj.dbInstance - the instance stored in the database that is being updated
 * @returns {string} key - the instance database key
 */
exports.updateInstance = async function ({ db, modelName, bodyInstance, dbInstance }) {
    try {
        if (!isEmpty(bodyInstance)) {
            Object.entries(bodyInstance).forEach(([key, val]) => {
                dbInstance[key] = val;
            });
            return await saveInstance(db, modelName, dbInstance);
        }
    }
    catch (error) {
        throw error;
    }
}

/**
 * setAdd - create/add to set with id, value
 * @param {object} db - the database client
 * @param {string} modelName - name of the new instance model
 * @param {string} fieldName - name of the relationship field
 * @param {string} value - the value to add to the set
 * @param {string} relatedId - (optional) parent/sibling id used in the set key
 * @returns {string} value - value added to the set
 */
const setAdd = async function (db, modelName, fieldName, value, relatedId = undefined) {
    const key = relatedId ? `${modelName}:${fieldName}:${relatedId}` : `${modelName}:${fieldName}`;
    await db.sadd(key, value);
    return value;
};
exports.setAdd = setAdd;

/**
 * orderedSetAdd - create/add to set with id, value
 * @param {object} db - the database client
 * @param {string} modelName - name of the new instance model
 * @param {string} fieldName - name of the relationship field
 * @param {object} expiration - the expiration object
 * @param {string} value - the value to add to the set
 * @param {string} relatedId - (optional) parent/sibling id used in the set key
 * @returns {string} value - value added to the sorted set 
 */
const orderedSetAdd = async function (db, modelName, fieldName, expiration, value, relatedId = undefined) {
    const key = relatedId ? `${modelName}:${fieldName}:${relatedId}` : `${modelName}:${fieldName}`;
    const timestamp = getFutureTimestamp(expiration);
    await db.zadd(key, timestamp, value);
    return value;
};
exports.orderedSetAdd = orderedSetAdd;

/**
 * listAdd - create/add to list with id, value
 * @param {object} db - the database client
 * @param {string} modelName - name of the new instance model
 * @param {string} fieldName - name of the relationship field
 * @param {string} value - the value to add to the set
 * @param {string} relatedId - (optional) parent/sibling id used in the set key
 * @returns {string} value - value added to the list
 */
const listAdd = async function (db, modelName, fieldName, value, relatedId = undefined) {
    const key = relatedId ? `${modelName}:${fieldName}:${relatedId}` : `${modelName}:${fieldName}`;
    await db.lpush(key, value);
    return value;
};
exports.listAdd = listAdd;

/**
 * assertUnique - check the DB to ensure an instance doesn't exists with a certain value for a specified field
 * @param {object} db - the database client
 * @param {string} modeName - the name of the instance model
 * @param {string} fieldName - the name of the field that must be unique
 * @param {*} fieldValue - the value to check if unique or not
 * @returns {boolean} isUnique 
 */
exports.assertUnique = async function (db, modelName, fieldName, fieldValue) {
    try {
        const storedInstance = getInstanceFromIndex({ 
            db, 
            modelName, 
            indexField: fieldName, 
            indexValue: fieldValue
        });
        if (isEmpty(storedInstance)) {
            return;
        }
        if (storedInstance[`${fieldName}Verified`] === true) {
            throw {
                error: new Error(),
                fieldName,
                notUnique: true
            };
        }
        return true;
    } 
    catch (error) {
        throw error;
    }
}
